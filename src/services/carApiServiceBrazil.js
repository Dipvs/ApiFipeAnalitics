const axios = require('axios');
const { getCarImage, formatPriceBRL, formatConsumption, convertMpgToKmL } = require('./carImageService');

// Configura√ß√£o da API FIPE
const FIPE_BASE_URL = 'https://parallelum.com.br/fipe/api/v2';

// Cache simples em mem√≥ria (em produ√ß√£o usar Redis)
const cache = {
  data: new Map(),
  set: (key, value, ttl = 3600000) => { // TTL padr√£o: 1 hora
    cache.data.set(key, {
      value,
      expiry: Date.now() + ttl
    });
  },
  get: (key) => {
    const item = cache.data.get(key);
    if (!item) return null;
    if (Date.now() > item.expiry) {
      cache.data.delete(key);
      return null;
    }
    return item.value;
  },
  clear: () => cache.data.clear()
};

// Tipos de ve√≠culos FIPE
const VEHICLE_TYPES = {
  'carros': 'cars',
  'motos': 'motorcycles', 
  'caminhoes': 'trucks'
};

// Fun√ß√£o para buscar marcas da FIPE
async function getFipeBrands(vehicleType = 'cars') {
  try {
    console.log(`üîç Buscando marcas FIPE para ${vehicleType}...`);
    
    const cacheKey = `fipe_brands_${vehicleType}`;
    const cached = cache.get(cacheKey);
    if (cached) {
      console.log('üì¶ Marcas encontradas no cache');
      return cached;
    }

    const response = await axios.get(`${FIPE_BASE_URL}/${vehicleType}/brands`, {
      timeout: 10000
    });

    console.log(`‚úÖ FIPE retornou ${response.data.length} marcas para ${vehicleType}`);
    
    const result = {
      success: true,
      data: response.data,
      source: 'fipe_api',
      total: response.data.length
    };

    // Cache por 2 horas (marcas mudam pouco)
    cache.set(cacheKey, result, 7200000);
    return result;

  } catch (error) {
    console.error('‚ùå Erro ao buscar marcas FIPE:', error.message);
    throw error;
  }
}

// Fun√ß√£o para buscar modelos por marca
async function getFipeModels(vehicleType = 'cars', brandId) {
  try {
    console.log(`üîç Buscando modelos FIPE para marca ${brandId}...`);
    
    const cacheKey = `fipe_models_${vehicleType}_${brandId}`;
    const cached = cache.get(cacheKey);
    if (cached) {
      console.log('üì¶ Modelos encontrados no cache');
      return cached;
    }

    const response = await axios.get(`${FIPE_BASE_URL}/${vehicleType}/brands/${brandId}/models`, {
      timeout: 10000
    });

    console.log(`‚úÖ FIPE retornou ${response.data.length} modelos`);
    
    const result = {
      success: true,
      data: response.data,
      source: 'fipe_api',
      total: response.data.length
    };

    // Cache por 1 hora
    cache.set(cacheKey, result);
    return result;

  } catch (error) {
    console.error('‚ùå Erro ao buscar modelos FIPE:', error.message);
    throw error;
  }
}

// Fun√ß√£o para buscar anos por modelo
async function getFipeYears(vehicleType = 'cars', brandId, modelId) {
  try {
    console.log(`üîç Buscando anos FIPE para modelo ${modelId}...`);
    
    const cacheKey = `fipe_years_${vehicleType}_${brandId}_${modelId}`;
    const cached = cache.get(cacheKey);
    if (cached) {
      console.log('üì¶ Anos encontrados no cache');
      return cached;
    }

    const response = await axios.get(`${FIPE_BASE_URL}/${vehicleType}/brands/${brandId}/models/${modelId}/years`, {
      timeout: 10000
    });

    console.log(`‚úÖ FIPE retornou ${response.data.length} anos`);
    
    const result = {
      success: true,
      data: response.data,
      source: 'fipe_api',
      total: response.data.length
    };

    cache.set(cacheKey, result);
    return result;

  } catch (error) {
    console.error('‚ùå Erro ao buscar anos FIPE:', error.message);
    throw error;
  }
}

// Fun√ß√£o para buscar detalhes completos do ve√≠culo
async function getFipeVehicleDetails(vehicleType = 'cars', brandId, modelId, yearId) {
  try {
    console.log(`üîç Buscando detalhes FIPE completos...`);
    
    const cacheKey = `fipe_details_${vehicleType}_${brandId}_${modelId}_${yearId}`;
    const cached = cache.get(cacheKey);
    if (cached) {
      console.log('üì¶ Detalhes encontrados no cache');
      return cached;
    }

    const response = await axios.get(`${FIPE_BASE_URL}/${vehicleType}/brands/${brandId}/models/${modelId}/years/${yearId}`, {
      timeout: 10000
    });

    const vehicleData = response.data;
    console.log(`‚úÖ FIPE retornou dados do ve√≠culo: ${vehicleData.brand} ${vehicleData.model}`);
    
    // Enriquecer dados com informa√ß√µes brasileiras
    const enrichedData = enrichFipeVehicleData(vehicleData);
    
    const result = {
      success: true,
      data: enrichedData,
      source: 'fipe_api'
    };

    cache.set(cacheKey, result);
    return result;

  } catch (error) {
    console.error('‚ùå Erro ao buscar detalhes FIPE:', error.message);
    throw error;
  }
}

// Fun√ß√£o para buscar ve√≠culos por c√≥digo FIPE
async function getFipeByCode(fipeCode, vehicleType = 'cars') {
  try {
    console.log(`üîç Buscando ve√≠culo por c√≥digo FIPE: ${fipeCode}...`);
    
    const cacheKey = `fipe_code_${fipeCode}_${vehicleType}`;
    const cached = cache.get(cacheKey);
    if (cached) {
      console.log('üì¶ Ve√≠culo encontrado no cache');
      return cached;
    }

    // Buscar anos dispon√≠veis para o c√≥digo FIPE
    const yearsResponse = await axios.get(`${FIPE_BASE_URL}/${vehicleType}/${fipeCode}/years`, {
      timeout: 10000
    });

    if (yearsResponse.data.length === 0) {
      throw new Error('C√≥digo FIPE n√£o encontrado');
    }

    // Pegar o primeiro ano dispon√≠vel (mais recente geralmente)
    const yearId = yearsResponse.data[0].code;
    
    // Buscar detalhes do ve√≠culo
    const detailsResponse = await axios.get(`${FIPE_BASE_URL}/${vehicleType}/${fipeCode}/years/${yearId}`, {
      timeout: 10000
    });

    const vehicleData = detailsResponse.data;
    console.log(`‚úÖ FIPE retornou dados por c√≥digo: ${vehicleData.brand} ${vehicleData.model}`);
    
    const enrichedData = enrichFipeVehicleData(vehicleData);
    
    const result = {
      success: true,
      data: enrichedData,
      source: 'fipe_api'
    };

    cache.set(cacheKey, result);
    return result;

  } catch (error) {
    console.error('‚ùå Erro ao buscar por c√≥digo FIPE:', error.message);
    throw error;
  }
}

// Fun√ß√£o principal de busca inteligente
async function smartCarSearch(filters = {}) {
  try {
    console.log('üîç Iniciando busca inteligente FIPE com filtros:', filters);
    
    const vehicleType = filters.type || 'cars';
    
    // Se tem c√≥digo FIPE, buscar diretamente
    if (filters.fipeCode) {
      return await getFipeByCode(filters.fipeCode, vehicleType);
    }
    
    // Busca por marca espec√≠fica
    if (filters.make && !filters.model) {
      return await searchVehiclesByMake(filters.make, vehicleType, filters);
    }
    
    // Busca por marca e modelo
    if (filters.make && filters.model) {
      return await searchVehiclesByMakeModel(filters.make, filters.model, vehicleType, filters);
    }
    
    // Busca geral - retornar algumas marcas populares
    return await getPopularBrands(vehicleType);

  } catch (error) {
    console.error('‚ùå Erro na busca FIPE:', error.message);
    
    // Fallback com dados gerados
    return generateFallbackCars(filters);
  }
}

// Buscar ve√≠culos por marca
async function searchVehiclesByMake(makeName, vehicleType = 'cars', filters = {}) {
  try {
    console.log(`üîç Buscando ve√≠culos da marca: ${makeName}`);
    
    // Buscar todas as marcas
    const brandsResult = await getFipeBrands(vehicleType);
    if (!brandsResult.success) throw new Error('Erro ao buscar marcas');
    
    // Encontrar marca correspondente
    const brand = brandsResult.data.find(b => 
      b.name.toLowerCase().includes(makeName.toLowerCase()) ||
      makeName.toLowerCase().includes(b.name.toLowerCase())
    );
    
    if (!brand) {
      throw new Error(`Marca ${makeName} n√£o encontrada`);
    }
    
    console.log(`‚úÖ Marca encontrada: ${brand.name} (c√≥digo: ${brand.code})`);
    
    // Buscar modelos da marca
    const modelsResult = await getFipeModels(vehicleType, brand.code);
    if (!modelsResult.success) throw new Error('Erro ao buscar modelos');
    
    console.log(`üìã ${modelsResult.data.length} modelos encontrados para ${brand.name}`);
    
    // Converter modelos para formato padr√£o
    const limit = parseInt(filters.limit) || 10;
    const selectedModels = modelsResult.data.slice(0, limit);
    
    console.log(`üöó Processando ${selectedModels.length} modelos...`);
    
    // Aguardar todas as promises de cria√ß√£o de ve√≠culos
    const vehicles = [];
    for (const model of selectedModels) {
      try {
        const vehicle = await createVehicleFromFipeModel(brand, model, vehicleType);
        if (vehicle && Object.keys(vehicle).length > 0) {
          vehicles.push(vehicle);
        }
      } catch (error) {
        console.error(`‚ùå Erro ao processar modelo ${model.name}:`, error.message);
      }
    }
    
    console.log(`‚úÖ ${vehicles.length} ve√≠culos processados com sucesso`);

    return {
      success: true,
      data: vehicles,
      total: vehicles.length,
      source: 'fipe_api',
      message: `${vehicles.length} ve√≠culos encontrados para ${brand.name}`
    };
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar por marca:', error.message);
    throw error;
  }
}

// Buscar ve√≠culos por marca e modelo
async function searchVehiclesByMakeModel(makeName, modelName, vehicleType = 'cars', filters = {}) {
  try {
    console.log(`üîç Buscando marca/modelo: ${makeName} ${modelName}`);
    
    // Buscar marca
    const brandsResult = await getFipeBrands(vehicleType);
    const brand = brandsResult.data.find(b => 
      b.name.toLowerCase().includes(makeName.toLowerCase())
    );
    
    if (!brand) throw new Error(`Marca ${makeName} n√£o encontrada`);
    console.log(`‚úÖ Marca encontrada: ${brand.name} (c√≥digo: ${brand.code})`);
    
    // Buscar modelos
    const modelsResult = await getFipeModels(vehicleType, brand.code);
    const model = modelsResult.data.find(m => 
      m.name.toLowerCase().includes(modelName.toLowerCase())
    );
    
    if (!model) throw new Error(`Modelo ${modelName} n√£o encontrado`);
    console.log(`‚úÖ Modelo encontrado: ${model.name} (c√≥digo: ${model.code})`);
    
    // Buscar detalhes de m√∫ltiplos anos para extrair m√°ximo de informa√ß√µes
    const limit = parseInt(filters.limit) || 5;
    const allYearDetailsResult = await getFipeVehicleDetailsAllYears(vehicleType, brand.code, model.code, limit);
    
    if (!allYearDetailsResult.success || allYearDetailsResult.data.length === 0) {
      throw new Error('Nenhum detalhe encontrado para este modelo');
    }
    
    console.log(`‚úÖ ${allYearDetailsResult.data.length} vers√µes encontradas com informa√ß√µes completas`);
    
    // Adicionar informa√ß√µes extras sobre a busca
    const enrichedVehicles = allYearDetailsResult.data.map(vehicle => ({
      ...vehicle,
      searchInfo: {
        searchedMake: makeName,
        searchedModel: modelName,
        foundBrand: brand,
        foundModel: model,
        searchTimestamp: new Date().toISOString()
      },
      detailedAnalysis: {
        totalAvailableYears: allYearDetailsResult.availableYears.length,
        yearsRange: {
          newest: allYearDetailsResult.availableYears[0]?.name,
          oldest: allYearDetailsResult.availableYears[allYearDetailsResult.availableYears.length - 1]?.name
        },
        priceAnalysis: calculatePriceAnalysis(allYearDetailsResult.data)
      }
    }));
      
    return {
      success: true,
      data: enrichedVehicles,
      total: enrichedVehicles.length,
      source: 'fipe_api',
      searchResults: {
        brandInfo: brand,
        modelInfo: model,
        availableYears: allYearDetailsResult.availableYears,
        totalYearsAvailable: allYearDetailsResult.availableYears.length
      },
      message: `${enrichedVehicles.length} vers√µes detalhadas encontradas para ${brand.name} ${model.name}`
    };
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar por marca/modelo:', error.message);
    throw error;
  }
}

// Obter marcas populares
async function getPopularBrands(vehicleType = 'cars') {
  try {
    const brandsResult = await getFipeBrands(vehicleType);
    if (!brandsResult.success) throw new Error('Erro ao buscar marcas');
    
    // Marcas brasileiras populares
    const popularBrandNames = [
      'Volkswagen', 'Chevrolet', 'Fiat', 'Ford', 'Toyota', 
      'Honda', 'Hyundai', 'Nissan', 'Renault', 'Peugeot'
    ];
    
    const popularBrands = brandsResult.data.filter(brand =>
      popularBrandNames.some(popular => 
        brand.name.toLowerCase().includes(popular.toLowerCase())
      )
    );

      return {
        success: true,
      data: popularBrands.slice(0, 10),
      total: popularBrands.length,
      source: 'fipe_api',
      message: 'Marcas populares no Brasil'
    };
    
    } catch (error) {
    console.error('‚ùå Erro ao buscar marcas populares:', error.message);
    throw error;
  }
}

// Criar ve√≠culo a partir de modelo FIPE
async function createVehicleFromFipeModel(brand, model, vehicleType) {
  console.log(`üîç Criando ve√≠culo: ${brand.name} ${model.name}`);
  
  try {
    // Buscar anos dispon√≠veis para o modelo
    const yearsResult = await getFipeYears(vehicleType, brand.code, model.code);
    
    if (yearsResult.success && yearsResult.data.length > 0) {
      // Pegar o primeiro ano dispon√≠vel (mais recente)
      const mostRecentYear = yearsResult.data[0];
      console.log(`üìÖ Ano mais recente encontrado: ${mostRecentYear.name}`);
      
      // Buscar detalhes completos com pre√ßos reais da FIPE
      const detailsResult = await getFipeVehicleDetails(vehicleType, brand.code, model.code, mostRecentYear.code);
      
      if (detailsResult.success) {
        console.log(`‚úÖ Dados reais FIPE obtidos para ${brand.name} ${model.name}`);
        // Retornar dados reais da FIPE
        return detailsResult.data;
      } else {
        console.log(`‚ö†Ô∏è Falha ao obter detalhes FIPE para ${brand.name} ${model.name}`);
      }
    } else {
      console.log(`‚ö†Ô∏è Nenhum ano encontrado para ${brand.name} ${model.name}`);
    }
  } catch (error) {
    console.log(`‚ö†Ô∏è Erro ao buscar dados reais FIPE para ${brand.name} ${model.name}:`, error.message);
  }
  
  // Fallback com dados estimados apenas se n√£o conseguir buscar dados reais
  console.log(`üõ°Ô∏è Usando dados estimados para ${brand.name} ${model.name}`);
  const currentYear = new Date().getFullYear();
  const estimatedYear = currentYear - Math.floor(Math.random() * 10);
  const estimatedPrice = generateBrazilianPrice(brand.name, model.name, estimatedYear);
  
  return {
    id: `${brand.code}_${model.code}`,
    brand: brand.name,
    model: model.name,
    year: estimatedYear,
    price: formatPriceBRL(estimatedPrice),
    priceNumber: estimatedPrice,
    fipeCode: `${brand.code}${model.code}`,
    vehicleType: vehicleType,
    fuel: 'Flex',
    transmission: 'Manual',
    doors: estimateDoorsFromType(vehicleType),
    seats: estimateSeatsFromType(vehicleType),
    origin: getBrandOrigin(brand.name),
    warranty: getBrandWarranty(brand.name),
    features: getBrazilianFeatures(vehicleType, estimatedPrice),
    consumption: {
      city: Math.floor(Math.random() * 5) + 8,
      highway: Math.floor(Math.random() * 5) + 12,
      combined: Math.floor(Math.random() * 5) + 10
    },
    performance: {
      power: Math.floor(Math.random() * 100) + 80,
      torque: Math.floor(Math.random() * 100) + 120,
      acceleration: (Math.random() * 5 + 8).toFixed(1),
      maxSpeed: Math.floor(Math.random() * 50) + 160
    },
    image: getCarImage(brand.name, model.name),
    dataSource: 'estimated' // Indicar que s√£o dados estimados
  };
}

// Enriquecer dados do ve√≠culo FIPE com todas as informa√ß√µes poss√≠veis
function enrichFipeVehicleData(fipeData) {
  console.log('üîç Dados brutos da FIPE:', JSON.stringify(fipeData, null, 2));
  
  // Converter pre√ßo FIPE para n√∫mero
  const priceString = fipeData.price || fipeData.valor || 'R$ 0,00';
  const priceNumber = parseFloat(priceString.replace(/[R$\s.]/g, '').replace(',', '.')) || 0;
  
  // Extrair ano do modelo
  const modelYear = fipeData.modelYear || fipeData.anoModelo || new Date().getFullYear();
  
  // Normalizar combust√≠vel
  const fuel = normalizeFuelType(fipeData.fuel || fipeData.combustivel || 'Gasolina');
  
  // Extrair marca e modelo
  const brand = fipeData.brand || fipeData.marca || 'Marca n√£o informada';
  const model = fipeData.model || fipeData.modelo || 'Modelo n√£o informado';
  
  // Extrair c√≥digo FIPE
  const fipeCode = fipeData.codeFipe || fipeData.codigoFipe || fipeData.code || '';
  
  // Extrair m√™s de refer√™ncia
  const referenceMonth = fipeData.referenceMonth || fipeData.mesReferencia || 'Atual';
  
  // Extrair tipo de ve√≠culo
  const vehicleType = getVehicleTypeFromFipe(fipeData.vehicleType || fipeData.tipoVeiculo);
  
  // Extrair sigla do combust√≠vel
  const fuelAcronym = getFuelAcronym(fuel);
  
  // Extrair hist√≥rico de pre√ßos se dispon√≠vel
  const priceHistory = fipeData.priceHistory || fipeData.historicoPrecos || [];
  
  // Extrair informa√ß√µes adicionais da FIPE
  const fipeAdditionalInfo = {
    authentication: fipeData.autenticacao || null,
    dataConsultation: fipeData.dataConsulta || new Date().toISOString(),
    fipeTable: fipeData.tabelaFipe || null,
    referenceCode: fipeData.codigoReferencia || null,
    searchedTerm: fipeData.termoPesquisado || null,
    queryDate: fipeData.dataConsulta || new Date().toISOString()
  };
  
  return {
    // IDs e c√≥digos
    id: fipeCode || Math.random().toString(36).substr(2, 9),
    fipeCode: fipeCode,
    
    // Informa√ß√µes b√°sicas
    brand: brand,
    make: brand, // Compatibilidade
    model: model,
    year: modelYear,
    modelYear: modelYear,
    
    // Pre√ßos
    price: formatPriceBRL(priceNumber),
    priceNumber: priceNumber,
    originalPrice: priceString,
    
    // Combust√≠vel
    fuel: fuel,
    fuelAcronym: fuelAcronym,
    originalFuel: fipeData.fuel || fipeData.combustivel,
    
    // Tipo de ve√≠culo
    vehicleType: vehicleType,
    originalVehicleType: fipeData.vehicleType || fipeData.tipoVeiculo,
    
    // Transmiss√£o estimada
    transmission: estimateTransmission(fuel),
    
    // Especifica√ß√µes estimadas
    doors: estimateDoorsFromModel(model),
    seats: estimateSeatsFromModel(model),
    
    // Caracter√≠sticas do mercado brasileiro
    origin: getBrandOrigin(brand),
    warranty: getBrandWarranty(brand),
    features: getBrazilianFeatures(model, priceNumber),
    
    // Performance estimada
    consumption: estimateConsumption(fuel, modelYear),
    performance: estimatePerformance(model, modelYear, fuel),
    
    // Imagem
    image: getCarImage(brand, model),
    
    // Dados da FIPE
    referenceMonth: referenceMonth,
    priceHistory: priceHistory,
    dataSource: 'fipe_api',
    
    // Informa√ß√µes adicionais da FIPE
    fipeInfo: fipeAdditionalInfo,
    
    // Dados brutos originais da FIPE (para debugging/an√°lise completa)
    rawFipeData: fipeData,
    
    // Timestamps
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
}

// Fun√ß√µes auxiliares
function normalizeFuelType(fipeFuel) {
  const fuelMap = {
    'Gasolina': 'Gasolina',
    '√Ålcool': 'Etanol', 
    'Diesel': 'Diesel',
    'Flex': 'Flex',
    'Gas': 'Gasolina'
  };
  return fuelMap[fipeFuel] || 'Flex';
}

function getFuelAcronym(fuel) {
  const acronymMap = {
    'Gasolina': 'G',
    'Etanol': 'E',
    '√Ålcool': 'E',
    'Diesel': 'D',
    'Flex': 'F',
    'El√©trico': 'EL',
    'H√≠brido': 'H'
  };
  return acronymMap[fuel] || 'F';
}

function getVehicleTypeFromFipe(vehicleType) {
  const typeMap = {
    1: 'Carro',
    2: 'Moto', 
    3: 'Caminh√£o',
    'cars': 'Carro',
    'motorcycles': 'Moto',
    'trucks': 'Caminh√£o'
  };
  return typeMap[vehicleType] || 'Carro';
}

function estimateTransmission(fuel) {
  // Carros mais novos e flex tendem a ser autom√°ticos
  return Math.random() > 0.6 ? 'Autom√°tico' : 'Manual';
}

function estimateDoorsFromModel(model) {
  if (model.toLowerCase().includes('2p') || model.toLowerCase().includes('conversivel')) return 2;
  if (model.toLowerCase().includes('4p') || model.toLowerCase().includes('sedan')) return 4;
  return Math.random() > 0.7 ? 2 : 4;
}

function estimateSeatsFromModel(model) {
  if (model.toLowerCase().includes('van') || model.toLowerCase().includes('kombi')) return 7;
  if (model.toLowerCase().includes('pickup') || model.toLowerCase().includes('suv')) return 5;
  return 5;
}

function estimateDoorsFromType(vehicleType) {
  if (vehicleType === 'motorcycles') return 0;
  if (vehicleType === 'trucks') return 2;
  return Math.random() > 0.7 ? 2 : 4;
}

function estimateSeatsFromType(vehicleType) {
  if (vehicleType === 'motorcycles') return 2;
  if (vehicleType === 'trucks') return 3;
  return 5;
}

function estimateConsumption(fuel, year) {
  const baseFactor = year > 2015 ? 1.2 : 1.0; // Carros mais novos s√£o mais eficientes
  const fuelFactor = fuel === 'Flex' ? 1.1 : fuel === 'Diesel' ? 1.3 : 1.0;
  
  const base = 10 * baseFactor * fuelFactor;

      return {
    city: Math.floor(base + Math.random() * 3),
    highway: Math.floor(base + Math.random() * 5 + 2),
    combined: Math.floor(base + Math.random() * 3 + 1)
  };
}

function estimatePerformance(model, year, fuel) {
  // Estimativas baseadas no modelo e ano
  const ageFactor = Math.max(0.8, 1 - (new Date().getFullYear() - year) * 0.02);
  const fuelFactor = fuel === 'Diesel' ? 1.3 : fuel === 'Flex' ? 1.1 : 1.0;
  
  let basePower = 100;
  if (model.toLowerCase().includes('sport')) basePower = 150;
  if (model.toLowerCase().includes('turbo')) basePower = 130;
  if (model.toLowerCase().includes('1.0')) basePower = 80;
  if (model.toLowerCase().includes('2.0')) basePower = 130;
  
  const power = Math.floor(basePower * ageFactor * fuelFactor);
  const torque = Math.floor(power * 1.3);
  const acceleration = (15 - (power / 20) + Math.random() * 2).toFixed(1);
  const maxSpeed = Math.floor(power * 1.8 + 100);
  
      return {
    power,
    torque, 
    acceleration: parseFloat(acceleration),
    maxSpeed
  };
}

function getBrandOrigin(brand) {
  const nationalBrands = ['Volkswagen', 'Chevrolet', 'Fiat', 'Ford'];
  const importedBrands = ['Toyota', 'Honda', 'Hyundai', 'Nissan'];
  
  if (nationalBrands.some(b => brand.toLowerCase().includes(b.toLowerCase()))) {
    return 'Nacional';
  }
  if (importedBrands.some(b => brand.toLowerCase().includes(b.toLowerCase()))) {
    return 'Importado';
  }
  return 'Nacional';
}

function getBrandWarranty(brand) {
  const warranties = {
    'Volkswagen': '3 anos',
    'Chevrolet': '3 anos', 
    'Fiat': '3 anos',
    'Ford': '3 anos',
    'Toyota': '3 anos',
    'Honda': '3 anos',
    'Hyundai': '5 anos'
  };
  
  for (const [b, warranty] of Object.entries(warranties)) {
    if (brand.toLowerCase().includes(b.toLowerCase())) {
      return warranty;
    }
  }
  return '3 anos';
}

function getBrazilianFeatures(model, price) {
  const basicFeatures = ['Dire√ß√£o hidr√°ulica', 'Vidros el√©tricos', 'Trava el√©trica'];
  const midFeatures = [...basicFeatures, 'Ar condicionado', 'Som MP3', 'Airbag duplo'];
  const premiumFeatures = [...midFeatures, 'Central multim√≠dia', 'C√¢mera de r√©', 'Sensores de estacionamento', 'Controle de estabilidade'];
  
  if (price > 80000) return premiumFeatures;
  if (price > 40000) return midFeatures;
  return basicFeatures;
}

function generateBrazilianPrice(make, model, year = 2024) {
  const currentYear = new Date().getFullYear();
  const age = currentYear - year;
  
  // Pre√ßo base por marca
  const basePrices = {
    'Volkswagen': 55000,
    'Chevrolet': 50000,
    'Fiat': 45000,
    'Ford': 48000,
    'Toyota': 65000,
    'Honda': 60000,
    'Hyundai': 55000,
    'Nissan': 58000
  };
  
  let basePrice = 45000; // Pre√ßo padr√£o
  
  // Encontrar pre√ßo base por marca
  for (const [brand, price] of Object.entries(basePrices)) {
    if (make.toLowerCase().includes(brand.toLowerCase())) {
      basePrice = price;
      break;
    }
  }
  
  // Ajustes por modelo
  if (model.toLowerCase().includes('sport')) basePrice *= 1.3;
  if (model.toLowerCase().includes('premium')) basePrice *= 1.4;
  if (model.toLowerCase().includes('basic')) basePrice *= 0.8;
  
  // Deprecia√ß√£o por ano
  const depreciationFactor = Math.max(0.3, 1 - (age * 0.08));
  const finalPrice = basePrice * depreciationFactor;
  
  // Adicionar varia√ß√£o aleat√≥ria
  const variation = 1 + (Math.random() - 0.5) * 0.2;
  
  return Math.floor(finalPrice * variation);
}

// Fun√ß√£o de fallback para casos de erro
function generateFallbackCars(filters = {}) {
  console.log('üõ°Ô∏è Gerando dados de fallback...');
  
  const fallbackCars = [
    {
      id: 'fallback_1',
      brand: 'Volkswagen',
      model: 'Gol 1.0',
      year: 2023,
      price: formatPriceBRL(45000),
      priceNumber: 45000,
      fipeCode: 'FALLBACK001',
      vehicleType: 'Carro',
      fuel: 'Flex',
      transmission: 'Manual',
      doors: 4,
      seats: 5,
      origin: 'Nacional',
      warranty: '3 anos',
      features: ['Dire√ß√£o hidr√°ulica', 'Vidros el√©tricos'],
      consumption: { city: 12, highway: 15, combined: 13 },
      performance: { power: 80, torque: 110, acceleration: 12.5, maxSpeed: 170 },
      image: getCarImage('Volkswagen', 'Gol')
    },
    {
      id: 'fallback_2', 
      brand: 'Chevrolet',
      model: 'Onix 1.0',
      year: 2023,
      price: formatPriceBRL(48000),
      priceNumber: 48000,
      fipeCode: 'FALLBACK002',
      vehicleType: 'Carro',
      fuel: 'Flex',
      transmission: 'Manual',
      doors: 4,
      seats: 5,
      origin: 'Nacional',
      warranty: '3 anos', 
      features: ['Ar condicionado', 'Central multim√≠dia'],
      consumption: { city: 13, highway: 16, combined: 14 },
      performance: { power: 82, torque: 112, acceleration: 12.8, maxSpeed: 175 },
      image: getCarImage('Chevrolet', 'Onix')
    }
  ];
  
  const limit = parseInt(filters.limit) || 10;

      return {
        success: true,
    data: fallbackCars.slice(0, limit),
    total: fallbackCars.length,
    source: 'fallback',
    message: 'Dados de exemplo (fallback)'
  };
}

  // Obter estat√≠sticas do mercado brasileiro
async function getBrazilianMarketStats() {
  try {
    console.log('üìä Gerando estat√≠sticas do mercado brasileiro...');
    
    const cacheKey = 'brazilian_market_stats';
    const cached = cache.get(cacheKey);
    if (cached) {
      console.log('üì¶ Estat√≠sticas encontradas no cache');
      return cached;
    }

    // Buscar marcas populares
    const brandsResult = await getFipeBrands('cars');
    const totalBrands = brandsResult.total || 0;
    
    // Marcas nacionais vs importadas
    const nationalBrands = ['Volkswagen', 'Chevrolet', 'Fiat', 'Ford'];
    const importedBrands = ['Toyota', 'Honda', 'Hyundai', 'Nissan', 'Renault'];
    
    const stats = {
      totalBrands: totalBrands,
      marketSegments: {
        nacional: nationalBrands.length,
        importado: importedBrands.length
      },
      popularBrands: brandsResult.data?.slice(0, 10).map(brand => ({
        name: brand.name,
        code: brand.code,
        category: nationalBrands.includes(brand.name) ? 'Nacional' : 'Importado'
      })) || [],
      vehicleTypes: {
        carros: 'Autom√≥veis de passeio',
        motos: 'Motocicletas',
        caminhoes: 'Caminh√µes e utilit√°rios'
      },
      priceRanges: {
        economico: 'R$ 20.000 - R$ 50.000',
        medio: 'R$ 50.000 - R$ 100.000',
        premium: 'R$ 100.000 - R$ 200.000',
        luxury: 'R$ 200.000+'
      },
      fuelTypes: {
        flex: 'Flex√≠vel (Gasolina/Etanol)',
        gasolina: 'Gasolina',
        diesel: 'Diesel',
        eletrico: 'El√©trico/H√≠brido'
      },
      marketTrends: {
        mostPopularFuel: 'Flex',
        averageAge: '8 anos',
        topSegment: 'Compactos',
        growthSector: 'SUVs'
      },
      dataSource: 'fipe_api',
      lastUpdated: new Date().toISOString(),
      coverage: 'Brasil - Tabela FIPE oficial'
    };

    const result = {
      success: true,
      data: stats,
      source: 'fipe_api',
      message: 'Estat√≠sticas do mercado brasileiro obtidas com sucesso'
    };

    // Cache por 6 horas
    cache.set(cacheKey, result, 21600000);
    return result;

  } catch (error) {
    console.error('‚ùå Erro ao gerar estat√≠sticas brasileiras:', error.message);
    
    // Retornar estat√≠sticas b√°sicas como fallback
      return {
        success: true,
        data: {
        totalBrands: 50,
        marketSegments: { nacional: 4, importado: 10 },
        dataSource: 'fallback',
        lastUpdated: new Date().toISOString(),
        message: 'Estat√≠sticas b√°sicas (dados de exemplo)'
      },
      source: 'fallback'
    };
  }
}

// Buscar detalhes completos de m√∫ltiplos anos de um modelo
async function getFipeVehicleDetailsAllYears(vehicleType = 'cars', brandId, modelId, maxYears = 5) {
  try {
    console.log(`üîç Buscando detalhes de m√∫ltiplos anos para modelo ${modelId}...`);
    
    // Buscar anos dispon√≠veis
    const yearsResult = await getFipeYears(vehicleType, brandId, modelId);
    if (!yearsResult.success || yearsResult.data.length === 0) {
      throw new Error('Nenhum ano encontrado');
    }

    console.log(`üìÖ ${yearsResult.data.length} anos dispon√≠veis`);
    
    // Limitar aos anos mais recentes
    const selectedYears = yearsResult.data.slice(0, maxYears);
    const allYearDetails = [];
    
    // Buscar detalhes para cada ano
    for (const year of selectedYears) {
      try {
        const detailsResult = await getFipeVehicleDetails(vehicleType, brandId, modelId, year.code);
        if (detailsResult.success) {
          allYearDetails.push({
            ...detailsResult.data,
            yearInfo: year, // Informa√ß√µes adicionais do ano
            detailsTimestamp: new Date().toISOString()
          });
        }
      } catch (error) {
        console.log(`‚ö†Ô∏è Erro ao buscar detalhes do ano ${year.name}:`, error.message);
      }
    }

    return {
      success: true,
      data: allYearDetails,
      total: allYearDetails.length,
      source: 'fipe_api',
      availableYears: yearsResult.data,
      message: `${allYearDetails.length} vers√µes encontradas com detalhes completos`
    };

  } catch (error) {
    console.error('‚ùå Erro ao buscar detalhes de m√∫ltiplos anos:', error.message);
    throw error;
  }
}

// Fun√ß√£o para calcular an√°lise de pre√ßos
function calculatePriceAnalysis(vehicles) {
  if (!vehicles || vehicles.length === 0) return null;
  
  const prices = vehicles.map(v => v.priceNumber || 0).filter(p => p > 0);
  
  if (prices.length === 0) return null;
  
  const minPrice = Math.min(...prices);
  const maxPrice = Math.max(...prices);
  const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
  
  return {
    minPrice: {
      value: minPrice,
      formatted: formatPriceBRL(minPrice)
    },
    maxPrice: {
      value: maxPrice,
      formatted: formatPriceBRL(maxPrice)
    },
    avgPrice: {
      value: Math.round(avgPrice),
      formatted: formatPriceBRL(Math.round(avgPrice))
    },
    priceRange: {
      value: maxPrice - minPrice,
      formatted: formatPriceBRL(maxPrice - minPrice)
    },
    totalVariations: prices.length,
    priceDistribution: prices.sort((a, b) => a - b)
  };
}

// Explorar informa√ß√µes adicionais da API FIPE
async function exploreFipeAdditionalInfo() {
  try {
    console.log('üîç Explorando informa√ß√µes adicionais da API FIPE...');
    
    const explorationResults = {
      baseUrl: FIPE_BASE_URL,
      timestamp: new Date().toISOString(),
      exploredEndpoints: []
    };

    // Testar endpoints para obter mais informa√ß√µes
    const endpointsToTest = [
      { path: '/cars/brands', description: 'Marcas de carros' },
      { path: '/motorcycles/brands', description: 'Marcas de motos' },
      { path: '/trucks/brands', description: 'Marcas de caminh√µes' },
      { path: '/references', description: 'Tabelas de refer√™ncia' },
      { path: '/info', description: 'Informa√ß√µes da API' },
      { path: '/tables', description: 'Tabelas dispon√≠veis' }
    ];

    for (const endpoint of endpointsToTest) {
      try {
        console.log(`üß™ Testando endpoint: ${endpoint.path}`);
        const response = await axios.get(`${FIPE_BASE_URL}${endpoint.path}`, {
          timeout: 5000
        });
        
        explorationResults.exploredEndpoints.push({
          path: endpoint.path,
          description: endpoint.description,
          status: 'success',
          dataType: Array.isArray(response.data) ? 'array' : typeof response.data,
          sampleData: Array.isArray(response.data) ? 
            response.data.slice(0, 2) : 
            response.data,
          totalItems: Array.isArray(response.data) ? response.data.length : 1
        });
        
        console.log(`‚úÖ ${endpoint.path}: ${response.status} - ${Array.isArray(response.data) ? response.data.length : 1} items`);
        
      } catch (error) {
        explorationResults.exploredEndpoints.push({
          path: endpoint.path,
          description: endpoint.description,
          status: 'error',
          error: error.message
        });
        console.log(`‚ùå ${endpoint.path}: ${error.message}`);
      }
    }

    return {
      success: true,
      data: explorationResults,
      source: 'fipe_exploration',
      message: `Explora√ß√£o conclu√≠da: ${explorationResults.exploredEndpoints.length} endpoints testados`
    };

  } catch (error) {
    console.error('‚ùå Erro na explora√ß√£o da FIPE:', error.message);
    throw error;
  }
}

// Buscar informa√ß√µes completas sobre as tabelas FIPE dispon√≠veis
async function getFipeTablesInfo() {
  try {
    console.log('üìã Buscando informa√ß√µes das tabelas FIPE...');
    
    const tablesInfo = {
      timestamp: new Date().toISOString(),
      vehicleTypes: {},
      totalStats: {}
    };

    // Buscar informa√ß√µes para cada tipo de ve√≠culo
    for (const [key, value] of Object.entries(VEHICLE_TYPES)) {
      try {
        console.log(`üìä Coletando estat√≠sticas para ${value}...`);
        
        const brandsResult = await getFipeBrands(value);
        if (brandsResult.success) {
          tablesInfo.vehicleTypes[key] = {
            type: value,
            totalBrands: brandsResult.total,
            sampleBrands: brandsResult.data.slice(0, 5),
            popularBrands: brandsResult.data.filter(brand => 
              ['Volkswagen', 'Chevrolet', 'Fiat', 'Ford', 'Toyota', 'Honda', 'Hyundai', 'Yamaha', 'Honda', 'Volvo'].some(popular =>
                brand.name.toLowerCase().includes(popular.toLowerCase())
              )
            ).slice(0, 10)
          };
        }
        
      } catch (error) {
        console.log(`‚ö†Ô∏è Erro ao coletar dados de ${value}:`, error.message);
        tablesInfo.vehicleTypes[key] = {
          type: value,
          error: error.message
        };
      }
    }

    // Calcular estat√≠sticas totais
    const totalBrands = Object.values(tablesInfo.vehicleTypes)
      .reduce((sum, type) => sum + (type.totalBrands || 0), 0);

    tablesInfo.totalStats = {
      totalVehicleTypes: Object.keys(tablesInfo.vehicleTypes).length,
      totalBrands: totalBrands,
      lastUpdated: new Date().toISOString(),
      dataSource: 'fipe_api'
    };

    return {
      success: true,
      data: tablesInfo,
      source: 'fipe_api',
      message: `Informa√ß√µes coletadas de ${Object.keys(tablesInfo.vehicleTypes).length} tipos de ve√≠culos`
    };

  } catch (error) {
    console.error('‚ùå Erro ao buscar informa√ß√µes das tabelas:', error.message);
    throw error;
  }
}

// Buscar refer√™ncias hist√≥ricas da FIPE
async function getFipeReferences() {
  try {
    console.log('üìÖ Buscando refer√™ncias hist√≥ricas da FIPE...');
    
    const cacheKey = 'fipe_references';
    const cached = cache.get(cacheKey);
    if (cached) {
      console.log('üì¶ Refer√™ncias encontradas no cache');
      return cached;
    }

    const response = await axios.get(`${FIPE_BASE_URL}/references`, {
      timeout: 10000
    });

    console.log(`‚úÖ FIPE retornou ${response.data.length} refer√™ncias hist√≥ricas`);
    
    const result = {
      success: true,
      data: response.data,
      source: 'fipe_api',
      total: response.data.length,
      analysis: {
        mostRecent: response.data[0],
        oldest: response.data[response.data.length - 1],
        totalMonths: response.data.length,
        yearRange: {
          from: response.data[response.data.length - 1]?.month?.match(/\d{4}/)?.[0],
          to: response.data[0]?.month?.match(/\d{4}/)?.[0]
        }
      }
    };

    // Cache por 24 horas (refer√™ncias mudam mensalmente)
    cache.set(cacheKey, result, 86400000);
    return result;

  } catch (error) {
    console.error('‚ùå Erro ao buscar refer√™ncias FIPE:', error.message);
    throw error;
  }
}

// Buscar pre√ßo hist√≥rico de um ve√≠culo espec√≠fico
async function getFipeVehicleHistoricalPrice(vehicleType = 'cars', brandId, modelId, yearId, referenceId) {
  try {
    console.log(`üìä Buscando pre√ßo hist√≥rico para refer√™ncia ${referenceId}...`);
    
    const cacheKey = `fipe_historical_${vehicleType}_${brandId}_${modelId}_${yearId}_${referenceId}`;
    const cached = cache.get(cacheKey);
    if (cached) {
      console.log('üì¶ Pre√ßo hist√≥rico encontrado no cache');
      return cached;
    }

    // Construir URL com refer√™ncia espec√≠fica
    const url = `${FIPE_BASE_URL}/${vehicleType}/brands/${brandId}/models/${modelId}/years/${yearId}`;
    const response = await axios.get(url, {
      params: { reference: referenceId },
      timeout: 10000
    });

    const historicalData = response.data;
    console.log(`‚úÖ Pre√ßo hist√≥rico obtido: ${historicalData.price} (${referenceId})`);
    
    const result = {
      success: true,
      data: {
        ...historicalData,
        referenceId: referenceId,
        historicalQuery: true,
        queryTimestamp: new Date().toISOString()
      },
      source: 'fipe_api'
    };

    // Cache por 1 hora
    cache.set(cacheKey, result);
    return result;

  } catch (error) {
    console.error('‚ùå Erro ao buscar pre√ßo hist√≥rico:', error.message);
    return {
      success: false,
      error: error.message,
      referenceId: referenceId
    };
  }
}

// Buscar evolu√ß√£o completa de pre√ßos de um ve√≠culo
async function getFipeVehiclePriceEvolution(vehicleType = 'cars', brandId, modelId, yearId, maxReferences = 12) {
  try {
    console.log(`üìà Buscando evolu√ß√£o de pre√ßos para ve√≠culo...`);
    
    // Buscar refer√™ncias dispon√≠veis
    const referencesResult = await getFipeReferences();
    if (!referencesResult.success) {
      throw new Error('N√£o foi poss√≠vel obter refer√™ncias');
    }

    console.log(`üìÖ ${referencesResult.data.length} refer√™ncias dispon√≠veis`);
    
    // Limitar n√∫mero de refer√™ncias para an√°lise
    const selectedReferences = referencesResult.data.slice(0, maxReferences);
    const priceEvolution = [];

    // Buscar pre√ßo para cada refer√™ncia
    for (const reference of selectedReferences) {
      try {
        const historicalResult = await getFipeVehicleHistoricalPrice(
          vehicleType, brandId, modelId, yearId, reference.code
        );
        
        if (historicalResult.success) {
          priceEvolution.push({
            reference: reference,
            price: historicalResult.data.price,
            priceNumber: parseFloat(historicalResult.data.price.replace(/[R$\s.]/g, '').replace(',', '.')) || 0,
            month: reference.month,
            vehicleData: historicalResult.data
          });
        }
        
        // Pequeno delay para n√£o sobrecarregar a API
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error) {
        console.log(`‚ö†Ô∏è Erro ao buscar pre√ßo para ${reference.month}:`, error.message);
      }
    }

    // Calcular an√°lise da evolu√ß√£o
    const priceAnalysis = calculatePriceEvolutionAnalysis(priceEvolution);

    return {
      success: true,
      data: {
        priceEvolution: priceEvolution,
        analysis: priceAnalysis,
        totalReferences: priceEvolution.length,
        requestedReferences: maxReferences,
        availableReferences: referencesResult.data.length
      },
      source: 'fipe_api',
      message: `Evolu√ß√£o de pre√ßos coletada para ${priceEvolution.length} per√≠odos`
    };

  } catch (error) {
    console.error('‚ùå Erro ao buscar evolu√ß√£o de pre√ßos:', error.message);
    throw error;
  }
}

// Calcular an√°lise da evolu√ß√£o de pre√ßos
function calculatePriceEvolutionAnalysis(priceEvolution) {
  if (!priceEvolution || priceEvolution.length === 0) return null;

  const prices = priceEvolution.map(p => p.priceNumber).filter(p => p > 0);
  if (prices.length === 0) return null;

  const oldestPrice = prices[prices.length - 1];
  const newestPrice = prices[0];
  const maxPrice = Math.max(...prices);
  const minPrice = Math.min(...prices);
  
  const percentualChange = ((newestPrice - oldestPrice) / oldestPrice) * 100;
  const absoluteChange = newestPrice - oldestPrice;

  return {
    oldestPrice: {
      value: oldestPrice,
      formatted: formatPriceBRL(oldestPrice),
      period: priceEvolution[priceEvolution.length - 1]?.month
    },
    newestPrice: {
      value: newestPrice,
      formatted: formatPriceBRL(newestPrice),
      period: priceEvolution[0]?.month
    },
    maxPrice: {
      value: maxPrice,
      formatted: formatPriceBRL(maxPrice)
    },
    minPrice: {
      value: minPrice,
      formatted: formatPriceBRL(minPrice)
    },
    change: {
      absolute: {
        value: absoluteChange,
        formatted: formatPriceBRL(Math.abs(absoluteChange))
      },
      percentual: {
        value: percentualChange,
        formatted: `${percentualChange.toFixed(2)}%`,
        direction: percentualChange >= 0 ? 'increase' : 'decrease'
      }
    },
    volatility: {
      range: maxPrice - minPrice,
      rangeFormatted: formatPriceBRL(maxPrice - minPrice),
      coefficient: ((maxPrice - minPrice) / ((maxPrice + minPrice) / 2)) * 100
    },
    trends: {
      isAppreciating: percentualChange > 0,
      isDepreciating: percentualChange < 0,
      isStable: Math.abs(percentualChange) < 5
    }
  };
}

// Exportar fun√ß√µes principais
module.exports = {
  smartCarSearch,
  getFipeBrands,
  getFipeModels,
  getFipeYears,
  getFipeVehicleDetails,
  getFipeVehicleDetailsAllYears,
  getFipeByCode,
  searchVehiclesByMake,
  searchVehiclesByMakeModel,
  getPopularBrands,
  getBrazilianMarketStats,
  calculatePriceAnalysis,
  cache,
  exploreFipeAdditionalInfo,
  getFipeTablesInfo,
  getFipeReferences,
  getFipeVehicleHistoricalPrice,
  getFipeVehiclePriceEvolution,
  calculatePriceEvolutionAnalysis
}; 